{
  "title": "Infrastructure as Code & Orchestration",
  "description": "Key insights, relationships, and decision points for Kubernetes, Helm, Terraform, and Ansible — the pillars of cloud-native infrastructure.",
  "tags": ["devops", "infrastructure", "kubernetes", "iac", "automation"],
  "createdAt": "2026-02-28T00:00:00Z",
  "updatedAt": "2026-02-28T00:00:00Z",
  "root": {
    "id": "root",
    "label": "IaC & Orchestration",
    "notes": "Four tools, two paradigms: declarative desired-state (K8s, Terraform, Helm) vs. imperative procedural automation (Ansible). Understanding where they overlap and where they complement each other is the real insight.",
    "annotation": "overview",
    "children": [
      {
        "id": "kubernetes",
        "label": "Kubernetes",
        "color": "#326CE5",
        "notes": "The de facto container orchestrator. K8s is NOT just deployment — it is a platform for building platforms. The API server + controller pattern makes it infinitely extensible via CRDs and operators.",
        "annotation": "orchestrator",
        "refs": [
          { "targetId": "helm", "label": "packaged by" },
          { "targetId": "tf-k8s-provider", "label": "provisioned by" },
          { "targetId": "ansible-k8s-module", "label": "configured by" }
        ],
        "children": [
          {
            "id": "k8s-key-insight",
            "label": "Key Insight: Reconciliation Loop",
            "color": "#326CE5",
            "notes": "Everything in K8s is a reconciliation loop: you declare desired state, controllers continuously work to make actual state match. This is the fundamental mental model — not 'run this command' but 'make it look like this'.",
            "annotation": "core concept",
            "refs": [{ "targetId": "tf-declarative", "label": "same paradigm" }]
          },
          {
            "id": "k8s-pod-lifecycle",
            "label": "Pod Lifecycle",
            "color": "#326CE5",
            "notes": "Pods are ephemeral by design. Never depend on a specific Pod surviving. This forces good architecture: stateless services, external state stores, health checks, graceful shutdown.",
            "annotation": "gotcha",
            "children": [
              {
                "id": "k8s-init-containers",
                "label": "Init Containers",
                "notes": "Run before app containers start. Perfect for migrations, config fetching, or waiting for dependencies. They run sequentially and must all succeed."
              },
              {
                "id": "k8s-probes",
                "label": "Liveness vs. Readiness",
                "notes": "Liveness probes restart unhealthy containers. Readiness probes remove Pods from Service endpoints. Getting these wrong causes cascading failures — a liveness probe that checks a database will kill your app when the DB is slow.",
                "annotation": "critical"
              },
              {
                "id": "k8s-resource-limits",
                "label": "Resource Requests & Limits",
                "notes": "Requests guarantee minimum resources for scheduling. Limits cap usage. Over-committing limits causes OOMKill; under-setting requests wastes cluster capacity. The ratio between them is your burst tolerance.",
                "annotation": "tuning"
              }
            ]
          },
          {
            "id": "k8s-networking",
            "label": "Networking Model",
            "color": "#326CE5",
            "notes": "K8s networking has one key rule: every Pod gets a routable IP, and every Pod can reach every other Pod without NAT. Everything else (Services, Ingress, NetworkPolicies) builds on this flat network.",
            "children": [
              {
                "id": "k8s-service-types",
                "label": "Service Discovery",
                "notes": "ClusterIP for internal traffic, NodePort for debugging, LoadBalancer for cloud integration. The DNS-based discovery (my-svc.my-namespace.svc.cluster.local) is how services find each other.",
                "refs": [
                  { "targetId": "k8s-service-mesh", "label": "enhanced by" }
                ]
              },
              {
                "id": "k8s-ingress-gateway",
                "label": "Ingress / Gateway API",
                "notes": "Ingress is being superseded by Gateway API — more expressive, role-oriented (infra admin vs. app developer), and supports TCP/UDP natively. Migrate to Gateway API for new clusters.",
                "annotation": "evolving"
              },
              {
                "id": "k8s-network-policies",
                "label": "Network Policies",
                "notes": "Default-deny is best practice. Without NetworkPolicies, any Pod can talk to any Pod — a lateral movement risk. Requires a CNI that supports them (Calico, Cilium).",
                "annotation": "security"
              },
              {
                "id": "k8s-service-mesh",
                "label": "Service Mesh",
                "notes": "Istio/Linkerd add mTLS, traffic splitting, observability. But they add complexity and resource overhead. Only adopt if you need fine-grained traffic control or zero-trust networking between services.",
                "annotation": "advanced"
              }
            ]
          },
          {
            "id": "k8s-storage",
            "label": "Stateful Workloads",
            "color": "#326CE5",
            "notes": "K8s was designed for stateless. Running stateful workloads (databases, queues) requires understanding PV/PVC lifecycle, StatefulSets ordering guarantees, and backup strategies. Often, managed services are simpler.",
            "annotation": "trade-off",
            "children": [
              {
                "id": "k8s-statefulsets",
                "label": "StatefulSets",
                "notes": "Ordered deployment, stable network IDs (pod-0, pod-1), persistent volumes per replica. Deletion does NOT delete PVCs — this is a safety feature, not a bug.",
                "refs": [{ "targetId": "k8s-operators", "label": "managed by" }]
              },
              {
                "id": "k8s-storage-classes",
                "label": "StorageClasses",
                "notes": "Abstract away storage backends. Dynamic provisioning means no pre-creating volumes. Key parameters: reclaimPolicy (Delete vs. Retain), volumeBindingMode (WaitForFirstConsumer avoids zone issues)."
              }
            ]
          },
          {
            "id": "k8s-security",
            "label": "Security Posture",
            "color": "#326CE5",
            "notes": "K8s is insecure by default. RBAC, Pod Security Standards, NetworkPolicies, and Secrets encryption at rest must all be explicitly configured.",
            "annotation": "critical",
            "children": [
              {
                "id": "k8s-rbac",
                "label": "RBAC",
                "notes": "Role + RoleBinding (namespace-scoped) or ClusterRole + ClusterRoleBinding (cluster-wide). Principle of least privilege. Audit who has 'cluster-admin' — it should be almost nobody.",
                "refs": [
                  { "targetId": "ansible-vault", "label": "secrets via" }
                ]
              },
              {
                "id": "k8s-pod-security",
                "label": "Pod Security Standards",
                "notes": "Three levels: Privileged (unrestricted), Baseline (prevents known escalations), Restricted (hardened). Enforce via namespace labels. Replaces the deprecated PodSecurityPolicy.",
                "annotation": "v1.25+"
              },
              {
                "id": "k8s-secrets-mgmt",
                "label": "Secrets Management",
                "notes": "K8s Secrets are base64-encoded, NOT encrypted by default. For real security: enable encryption at rest, use external secret stores (Vault, AWS Secrets Manager) via CSI driver or external-secrets operator.",
                "annotation": "gotcha",
                "refs": [
                  { "targetId": "ansible-vault", "label": "alternative" }
                ]
              }
            ]
          },
          {
            "id": "k8s-extensibility",
            "label": "Extensibility",
            "color": "#326CE5",
            "notes": "The real power of K8s: CRDs + Operators turn it into a platform for anything. Databases, certificates, CI/CD, ML workloads — all managed through the same kubectl interface.",
            "children": [
              {
                "id": "k8s-operators",
                "label": "Operators",
                "notes": "Encode operational knowledge as code. Instead of runbooks, the operator watches custom resources and takes action. Examples: Prometheus Operator, cert-manager, CloudNativePG.",
                "annotation": "pattern",
                "refs": [{ "targetId": "helm-hooks", "label": "lifecycle via" }]
              },
              {
                "id": "k8s-crds",
                "label": "Custom Resources",
                "notes": "Extend the K8s API with your own resource types. CRDs define the schema; operators implement the controller logic. This is how the ecosystem grows without forking K8s."
              }
            ]
          }
        ]
      },
      {
        "id": "helm",
        "label": "Helm",
        "color": "#0F1689",
        "notes": "The package manager for K8s. Helm solves the 'YAML sprawl' problem by templatizing manifests and managing release lifecycle. The key insight: Helm is not just templating — it is versioned release management.",
        "annotation": "packaging",
        "refs": [{ "targetId": "kubernetes", "label": "deploys to" }],
        "children": [
          {
            "id": "helm-key-insight",
            "label": "Key Insight: Releases != Templates",
            "color": "#0F1689",
            "notes": "Helm's value is not in Go templates (Kustomize does overlays better). It is in release management: install, upgrade, rollback, history. Every `helm upgrade` creates a revision you can roll back to.",
            "annotation": "insight",
            "refs": [{ "targetId": "k8s-kustomize", "label": "vs." }]
          },
          {
            "id": "helm-charts",
            "label": "Chart Anatomy",
            "color": "#0F1689",
            "notes": "Chart.yaml (metadata), values.yaml (defaults), templates/ (Go templates), charts/ (dependencies). Understanding the render pipeline: values merge -> template execution -> manifest output.",
            "children": [
              {
                "id": "helm-values-strategy",
                "label": "Values Strategy",
                "notes": "Layer values: chart defaults < environment values < CI overrides < --set flags. Keep secrets out of values files — use external-secrets or sealed-secrets instead.",
                "annotation": "best practice"
              },
              {
                "id": "helm-dependencies",
                "label": "Chart Dependencies",
                "notes": "Subcharts for composing complex deployments (app + database + cache). Use 'condition' and 'tags' in Chart.yaml to make dependencies optional. Watch for version conflicts."
              }
            ]
          },
          {
            "id": "helm-lifecycle",
            "label": "Release Lifecycle",
            "color": "#0F1689",
            "notes": "install -> upgrade -> rollback -> uninstall. Each operation is tracked. `helm diff` plugin shows what will change before applying.",
            "children": [
              {
                "id": "helm-hooks",
                "label": "Hooks",
                "notes": "Run Jobs at lifecycle points (pre-install, post-upgrade, pre-delete). Use for DB migrations, smoke tests, cleanup. Weight controls ordering when multiple hooks exist.",
                "annotation": "advanced"
              },
              {
                "id": "helm-rollback",
                "label": "Rollback Strategy",
                "notes": "Revisions are stored as K8s Secrets. `helm rollback release 3` restores revision 3. But rollback only reverts K8s resources — if a DB migration ran, you need a separate rollback plan.",
                "annotation": "gotcha"
              }
            ]
          },
          {
            "id": "k8s-kustomize",
            "label": "Helm vs. Kustomize",
            "color": "#0F1689",
            "notes": "Kustomize: template-free, patch-based, built into kubectl. Better for teams that own all their manifests. Helm: better for distributing reusable packages and third-party charts. Many teams use both.",
            "annotation": "decision"
          }
        ]
      },
      {
        "id": "terraform",
        "label": "Terraform",
        "color": "#7B42BC",
        "notes": "Infrastructure as Code for cloud resources. Terraform's strength is its multi-cloud provider ecosystem and the plan/apply workflow that shows changes before making them. OpenTofu is the open-source fork.",
        "annotation": "provisioner",
        "refs": [
          { "targetId": "ansible", "label": "hands off to" },
          { "targetId": "kubernetes", "label": "creates clusters for" }
        ],
        "children": [
          {
            "id": "tf-declarative",
            "label": "Key Insight: State is Everything",
            "color": "#7B42BC",
            "notes": "Terraform's state file is the single source of truth mapping config to real resources. If state is lost, Terraform loses track of what it manages. Remote state backends with locking are non-negotiable for teams.",
            "annotation": "critical",
            "refs": [
              { "targetId": "k8s-key-insight", "label": "same paradigm" }
            ]
          },
          {
            "id": "tf-workflow",
            "label": "Plan-Apply Workflow",
            "color": "#7B42BC",
            "notes": "init -> plan -> apply -> destroy. The 'plan' step is what makes Terraform safe: you see exactly what will be created, modified, or destroyed before it happens.",
            "children": [
              {
                "id": "tf-plan-safety",
                "label": "Plan is Your Safety Net",
                "notes": "Always review plans in CI. Use saved plan files (`terraform plan -out=tfplan`) to ensure what you reviewed is what gets applied. Never skip plan review for production.",
                "annotation": "best practice"
              },
              {
                "id": "tf-drift",
                "label": "State Drift",
                "notes": "If someone manually changes infrastructure, Terraform state drifts from reality. `terraform plan` detects drift. `terraform refresh` updates state (now implicit in plan). Regular drift detection catches manual changes.",
                "annotation": "gotcha",
                "refs": [
                  {
                    "targetId": "ansible-idempotency",
                    "label": "related concept"
                  }
                ]
              }
            ]
          },
          {
            "id": "tf-modules",
            "label": "Module Architecture",
            "color": "#7B42BC",
            "notes": "Modules are the unit of reuse. A well-designed module encapsulates a logical infrastructure unit (VPC, EKS cluster, RDS instance) with clean inputs/outputs.",
            "children": [
              {
                "id": "tf-module-patterns",
                "label": "Module Patterns",
                "notes": "Root module = your environment config. Child modules = reusable components. Pin module versions. Use terraform-docs to auto-generate documentation. Keep modules focused — one concern per module.",
                "annotation": "pattern"
              },
              {
                "id": "tf-module-composition",
                "label": "Module Composition",
                "notes": "Pass outputs of one module as inputs to another. This creates an explicit dependency graph. Terraform resolves the ordering automatically. Avoid circular dependencies.",
                "refs": [
                  { "targetId": "helm-dependencies", "label": "similar to" }
                ]
              }
            ]
          },
          {
            "id": "tf-k8s-provider",
            "label": "Terraform + K8s",
            "color": "#7B42BC",
            "notes": "Use Terraform to provision the cluster (EKS, GKE, AKS) and core infrastructure. Use Helm/kubectl for application deployments. Don't try to manage every K8s resource via Terraform — it fights the K8s reconciliation model.",
            "annotation": "boundary",
            "refs": [
              { "targetId": "kubernetes", "label": "provisions" },
              { "targetId": "helm", "label": "complements" }
            ]
          },
          {
            "id": "tf-advanced",
            "label": "Advanced Patterns",
            "color": "#7B42BC",
            "children": [
              {
                "id": "tf-workspaces",
                "label": "Workspaces vs. Directories",
                "notes": "Workspaces share code but have separate state. Works for simple env differences. For significantly different environments, separate directories (with shared modules) give more control and less risk.",
                "annotation": "decision"
              },
              {
                "id": "tf-import",
                "label": "Import Existing Infra",
                "notes": "terraform import brings existing resources under management. Terraform 1.5+ supports declarative import blocks. Always plan after import to ensure config matches reality.",
                "annotation": "migration"
              }
            ]
          }
        ]
      },
      {
        "id": "ansible",
        "label": "Ansible",
        "color": "#EE0000",
        "notes": "Configuration management and orchestration. Ansible fills the gap between 'infrastructure exists' (Terraform) and 'application is deployed' (K8s/Helm). Agentless, SSH-based, YAML-driven. Best for mutable infrastructure and day-2 operations.",
        "annotation": "configurator",
        "refs": [
          { "targetId": "terraform", "label": "receives from" },
          { "targetId": "kubernetes", "label": "bootstraps" }
        ],
        "children": [
          {
            "id": "ansible-key-insight",
            "label": "Key Insight: Procedural + Idempotent",
            "color": "#EE0000",
            "notes": "Unlike Terraform/K8s (declarative), Ansible playbooks are procedural — order matters. But individual modules are idempotent. This hybrid gives flexibility for complex multi-step provisioning that pure declarative tools struggle with.",
            "annotation": "paradigm",
            "refs": [
              { "targetId": "tf-declarative", "label": "vs. declarative" },
              { "targetId": "k8s-key-insight", "label": "vs. reconciliation" }
            ]
          },
          {
            "id": "ansible-when-to-use",
            "label": "When to Use Ansible",
            "color": "#EE0000",
            "notes": "Use Ansible when: configuring VMs/bare metal, running ad-hoc operational tasks, multi-step orchestration that needs ordering, bootstrapping systems before K8s/Terraform can take over. Don't use it for what K8s/Terraform do better.",
            "annotation": "decision",
            "children": [
              {
                "id": "ansible-k8s-module",
                "label": "Ansible + K8s",
                "notes": "Ansible has k8s modules (community.kubernetes) for managing K8s resources. Useful for bootstrapping clusters or environments where Helm is not available. But for ongoing app management, Helm/ArgoCD is usually better.",
                "refs": [
                  { "targetId": "kubernetes", "label": "manages" },
                  { "targetId": "helm", "label": "alternative to" }
                ]
              },
              {
                "id": "ansible-tf-handoff",
                "label": "Terraform -> Ansible",
                "notes": "Common pattern: Terraform provisions infrastructure, outputs inventory (IPs, hostnames), Ansible takes over for configuration. Dynamic inventory plugins read directly from cloud APIs or Terraform state.",
                "annotation": "pattern",
                "refs": [{ "targetId": "terraform", "label": "receives from" }]
              }
            ]
          },
          {
            "id": "ansible-playbooks",
            "label": "Playbook Architecture",
            "color": "#EE0000",
            "notes": "Playbooks are ordered lists of plays. Roles are the unit of reuse. A well-structured project: inventory per environment, group_vars for configuration, site.yml as the entry point, roles for each concern.",
            "children": [
              {
                "id": "ansible-idempotency",
                "label": "Idempotency Gotchas",
                "notes": "Most modules are idempotent, but shell/command modules are NOT unless you add 'creates' or 'when' guards. Always test playbooks by running them twice — the second run should report 0 changes.",
                "annotation": "gotcha",
                "refs": [{ "targetId": "tf-drift", "label": "related concept" }]
              },
              {
                "id": "ansible-roles",
                "label": "Roles & Galaxy",
                "notes": "Roles standardize structure: tasks/, handlers/, defaults/, vars/, templates/, files/. Galaxy is the package manager. Pin role versions in requirements.yml. Prefer collections (ansible-galaxy collection install) over standalone roles."
              }
            ]
          },
          {
            "id": "ansible-vault",
            "label": "Secrets & Vault",
            "color": "#EE0000",
            "notes": "Ansible Vault encrypts sensitive data at rest within YAML files. For production, integrate with external secret stores (HashiCorp Vault, AWS Secrets Manager) rather than storing encrypted secrets in git.",
            "annotation": "security",
            "refs": [{ "targetId": "k8s-secrets-mgmt", "label": "complements" }]
          }
        ]
      },
      {
        "id": "cross-cutting",
        "label": "Cross-Cutting Concerns",
        "color": "#10B981",
        "notes": "Patterns and concerns that span all four tools. The best infrastructure is built by combining tools at their strengths, not by forcing one tool to do everything.",
        "annotation": "synthesis",
        "children": [
          {
            "id": "gitops",
            "label": "GitOps",
            "color": "#10B981",
            "notes": "Git as the single source of truth for both infrastructure (Terraform) and application state (K8s manifests/Helm charts). ArgoCD or Flux for K8s, Atlantis for Terraform. Pull-based reconciliation, not push-based CI/CD.",
            "annotation": "methodology",
            "refs": [
              { "targetId": "k8s-key-insight", "label": "enables" },
              { "targetId": "tf-declarative", "label": "enables" },
              { "targetId": "helm-lifecycle", "label": "automates" }
            ]
          },
          {
            "id": "tool-boundaries",
            "label": "Where Each Tool Fits",
            "color": "#10B981",
            "notes": "Terraform: provision cloud resources (VPCs, clusters, databases). Ansible: configure VMs, bootstrap systems. Helm: package and deploy K8s applications. K8s: run and scale containerized workloads. Overlap exists — draw clear boundaries in your team.",
            "annotation": "key decision"
          },
          {
            "id": "testing-strategy",
            "label": "Testing Infrastructure",
            "color": "#10B981",
            "notes": "Terraform: `terraform validate`, tfsec, Checkov, Terratest. Helm: `helm lint`, `helm test`, chart-testing (ct). Ansible: ansible-lint, Molecule, TestInfra. K8s: conftest (OPA), kube-score, Polaris.",
            "children": [
              {
                "id": "policy-as-code",
                "label": "Policy as Code",
                "notes": "OPA/Gatekeeper for K8s admission control, Sentinel for Terraform Cloud, conftest for CI. Enforce security and compliance before resources are created, not after.",
                "annotation": "shift-left",
                "refs": [
                  { "targetId": "k8s-pod-security", "label": "enforced by" },
                  { "targetId": "k8s-network-policies", "label": "complements" }
                ]
              }
            ]
          },
          {
            "id": "observability",
            "label": "Observability",
            "color": "#10B981",
            "notes": "Logs, metrics, traces across all layers. Prometheus + Grafana for K8s metrics. Cloud provider tools for Terraform-managed resources. Centralized logging (ELK, Loki) for Ansible runs and K8s workloads.",
            "refs": [{ "targetId": "k8s-service-mesh", "label": "enhanced by" }]
          }
        ]
      }
    ]
  }
}
